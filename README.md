# AGL Anonymizer - API built from flake.nix

AGL Anonymizer is a Django-based API that interacts with the AGL Anonymizer Pipeline. This API is designed to facilitate the seamless integration of the anonymization functionalities in agl_anonymizer_pipeline into new applications, ensuring privacy and compliance with data protection regulations.

## Disclaimer

This is a study version of the program. Later Versions could one day provide full anonymization of patient data. However, at the current state no warranty for the quality of results can be given.
Names used in the name generation dictionary are entirely handpicked from data generated by AI (ChatGPT). No Resemblance to actual people, living or dead, is intended.


## Features of this Repository

- **Text Pseudonymization Interface**
- **Sending And Recieving Data**
- **Image Saving**
- **Extensive Format Support**

## Functionality

When this project is started, a Django REST API is set up. This API can be called with a provided image path. Once the anonymization is complete, an image path to a anonymized result will be returned as a response.
 
## Installation

AGL Anonymizer is set up by a comprehensive flake.nix. This file defines all inputs to the program, enables CUDA on the system and then sets up a python environment containing all the dependencies. To start the installation follow these steps:

1. **Clone the Repository**:
    ```bash
    git clone https://github.com/wg-lux/agl_anonymizer.git
    cd agl_anonymizer
    ```

2. **Set Up the Development Environment**:
    ```bash
    nix develop
    ```

3. **Install Dependencies**:
    Ensure you have all required dependencies installed. Refer to `pypoetry.toml` for a list of dependencies.
    test the python environment by typing
   ```bash
   poetry update
   ``

5. **Download the Text Detection Model**:
    If the automatic download from github fails, ownload a text detection model, such as `frozen_east_text_detection.pb`, and place it in the appropriate directory of a local version of agl_anonymizer       pipeline. All models are downloaded automatically.

## Usage

To use the AGL Anonymizer API, follow these steps:

1. **Prepare Your Images**:
   Place the images you want to process in a designated folder.

2. **Configure Settings**:
   Adjust settings in the configuration file (if applicable) to suit your anonymizing and blurring needs.

3. **Run the Django Server**:
    ```bash
    python manage.py runserver
    ```

4. **Make API Requests**:
   Use an API client like Postman, cURL, or the `requests` library in Python to interact with the AGL Anonymizer API. Example request using the `requests` library:

    ```python
    import requests
    import os

    # Get the directory of the current script
    base_dir = os.path.dirname(os.path.abspath(__file__))

    # Define the path to the image file located in the 'requests_agl_anonymizer' folder
    image_path = os.path.join(base_dir, 'frame_0.jpg')

    # Ensure the file exists
    if not os.path.exists(image_path):
        raise FileNotFoundError(f"No such file or directory: '{image_path}'")

    # Define the URL of the Django API endpoint
    url = 'http://127.0.0.1:8000/process/'

    # Open the file in binary mode and send it as part of the multipart form-data payload
    with open(image_path, 'rb') as image_file:
        files = {
            'file': image_file,
        }
        data = {
            'title': 'Example Image',
        }
        response = requests.post(url, files=files, data=data)

    # Print the response from the server
    print(response.status_code)
    print(response.json())  # Assuming the server returns a JSON response
    ```

## API Endpoints

- **/process/**: Endpoint to upload images and receive anonymized results.



### UploadedFile

Represents an uploaded file with fields for the original file, upload date, and an optional description.

```python
from django.db import models
from django.utils import timezone

class UploadedFile(models.Model):
    original_file = models.FileField(upload_to='uploads/original/')
    upload_date = models.DateTimeField(default=timezone.now)
    description = models.TextField(blank=True, null=True)
    
    def __str__(self):
        return self.original_file.name
